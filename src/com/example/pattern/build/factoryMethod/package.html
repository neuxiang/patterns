<Body>

工厂方法(Factory Method)/虚拟构造子(virtual Constructor)/多态性工厂(Polymorphic Factory)模式<br />
 <img src="{@docRoot}/images/factoryMethod.gif" width="603" height="212"><br />





<ul>
  <li><strong>意图:</strong>定义一个用于创建对象的接口，让子类决定实例化哪一个类。使一个类的实例化延迟到其子类。</li>
  <li><strong>问题:</strong>一个类需要实例化另一个类的派生类，但不知道具体是哪个派生类。此模式允许让派生类来做出决定。</li>
  <li><strong>注意:</strong>暂无</li>
</ul>
客户类和工厂类分开。消费者任何时候需要某种产品，只需向工厂请求即可。消费者无须修改就可以接纳新产品。<br>
缺点是当产品修改时，工厂类也要做相应的修改。但只需修改这个一个地方。<br>


目的：调用和创建分离。<br>
调用端无需改变，创建方法可在符合规约接口前提下，自由修改。工厂方法模式在于把创建方法放在工厂里，所有调用者都调用工厂创建对象，而不是直接用new创建。<br>
好处在于，一旦被创建的实例发生改变时，不需要更改所有用new创建实例的地方，而只需更改工厂即可。Spring的依赖注入或叫控制反转就是将创建工厂设计成配置文件，产品发生变化时只需修改配置文件，如果用标记式开发什么都不用改。<br>
总结：子类产品的修改，不影响调用者代码的变动。<br>
原则：不变的抽象定义引用，变化的封装到子类。变化的不影响不变的。<br>

</Body>